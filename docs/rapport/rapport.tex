\documentclass[12pt,a4paper]{article}

% Packages essentiels
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{titlesec}

\geometry{margin=2.5cm}

% Configuration des en-têtes
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Labellisation des Composantes Connexes}
\fancyhead[R]{\small\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Configuration des listings
\lstset{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    xleftmargin=1em
}

% Configuration hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    pdftitle={Labellisation des Composantes Connexes},
    pdfauthor={Despoullain, Marano, Braham}
}

% Espacement des sections
\titlespacing*{\section}{0pt}{2ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titlespacing*{\subsection}{0pt}{1.5ex plus 1ex minus .2ex}{1ex plus .2ex}

\begin{document}

% ===========================================
% PAGE DE TITRE
% ===========================================
\begin{titlepage}
\centering
\vspace*{2cm}

{\Large\textsc{Université / École}\par}
\vspace{0.5cm}
{\large Traitement d'Images\par}

\vspace{3cm}

{\Huge\bfseries Labellisation des Composantes Connexes\par}
\vspace{0.5cm}
{\Large Analyse Comparative de Quatre Algorithmes\par}

\vspace{3cm}

{\large
\begin{tabular}{c}
Romain Despoullain \\
Nicolas Marano \\
Amin Braham
\end{tabular}
\par}

\vfill

{\large \today\par}
\end{titlepage}

% ===========================================
% RÉSUMÉ
% ===========================================
\thispagestyle{empty}
\section*{Résumé}

Ce rapport présente une étude comparative de quatre algorithmes de labellisation des composantes connexes : Two-Pass, Union-Find, Kruskal et Prim. L'implémentation Python utilise NumPy/OpenCV uniquement pour le chargement des images. Les résultats montrent que Two-Pass et Union-Find offrent les meilleures performances, tandis que Kruskal présente un surcoût dû à la création explicite des arêtes.

\vspace{1cm}
\tableofcontents

\newpage
\setcounter{page}{1}

% ===========================================
% INTRODUCTION
% ===========================================
\section{Introduction}

\subsection{Contexte}

La \textbf{labellisation des composantes connexes} (CCL) est une opération fondamentale en traitement d'images. Elle consiste à identifier et étiqueter les régions connexes dans une image binaire.

Applications principales :
\begin{itemize}
    \item Vision par ordinateur : détection d'objets
    \item Analyse de documents : segmentation de caractères
    \item Imagerie médicale : identification de structures
    \item Contrôle qualité industriel
\end{itemize}

\subsection{Définition formelle}

Soit une image binaire $I : \Omega \rightarrow \{0, 1\}$. La labellisation consiste à trouver $L : \Omega \rightarrow \mathbb{N}$ telle que :
\begin{equation}
    L(p) = L(q) \Leftrightarrow p \sim q
\end{equation}
où $p \sim q$ signifie qu'il existe un chemin de pixels adjacents reliant $p$ à $q$.

\subsection{Objectifs}

\begin{enumerate}
    \item Implémenter quatre algorithmes de labellisation
    \item Comparer leurs performances
    \item Analyser l'impact de la connectivité (4 vs 8 voisins)
\end{enumerate}

% ===========================================
% FONDEMENTS THÉORIQUES
% ===========================================
\newpage
\section{Fondements Théoriques}

\subsection{Adjacence et connexité}

\paragraph{4-adjacence} Deux pixels $p$ et $q$ sont 4-adjacents si :
\begin{equation}
    |x_1 - x_2| + |y_1 - y_2| = 1
\end{equation}

\paragraph{8-adjacence} Deux pixels sont 8-adjacents si :
\begin{equation}
    \max(|x_1 - x_2|, |y_1 - y_2|) = 1
\end{equation}

\subsection{Paradoxe de Jordan}

Le choix de la même connexité pour l'objet et le fond crée des incohérences topologiques. Solution : utiliser des adjacences duales (4-connexité pour l'objet, 8-connexité pour le fond).

\subsection{Modélisation par graphe}

L'image est modélisée comme un graphe $G = (V, E)$ où $V$ représente les pixels et $E$ les adjacences. Les composantes connexes correspondent aux composantes connexes du graphe.

\subsection{Structure Union-Find}

Structure permettant de gérer une partition avec deux opérations :
\begin{itemize}
    \item \texttt{Find(x)} : retourne le représentant de l'ensemble contenant $x$
    \item \texttt{Union(x, y)} : fusionne les ensembles contenant $x$ et $y$
\end{itemize}

Avec compression de chemin et union par rang, la complexité amortie est $O(\alpha(n))$ (quasi-constante).

% ===========================================
% ALGORITHMES
% ===========================================
\newpage
\section{Description des Algorithmes}

\subsection{Two-Pass}

Algorithme classique en deux passes :

\begin{algorithm}[H]
\caption{Two-Pass}
\begin{algorithmic}[1]
\State \textbf{Passe 1 :} Attribution d'étiquettes provisoires
\For{chaque pixel $(x, y)$ de l'image}
    \If{pixel est objet}
        \State Examiner les voisins déjà traités
        \If{aucun voisin labellisé}
            \State Créer nouveau label
        \Else
            \State Prendre le min des labels voisins
            \State Enregistrer les équivalences
        \EndIf
    \EndIf
\EndFor
\State \textbf{Passe 2 :} Résolution des équivalences
\For{chaque pixel}
    \State Remplacer label par sa racine
\EndFor
\end{algorithmic}
\end{algorithm}

\textbf{Complexité :} $O(n)$ en temps et espace.

\subsection{Union-Find}

Utilise directement la structure Union-Find. Chaque pixel forme initialement son propre ensemble, puis les ensembles sont fusionnés lors du parcours.

\begin{lstlisting}[caption=Compression de chemin]
def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])
    return self.parent[x]
\end{lstlisting}

\textbf{Complexité :} $O(n \cdot \alpha(n)) \approx O(n)$

\subsection{Kruskal}

Adapte l'algorithme de l'arbre couvrant minimum :
\begin{enumerate}
    \item Construire la liste des arêtes (adjacences entre pixels objets)
    \item Parcourir les arêtes et fusionner les composantes via Union-Find
\end{enumerate}

\textbf{Complexité :} $O(E \cdot \alpha(V))$ où $E$ est le nombre d'arêtes.

\textbf{Inconvénient :} Création explicite de toutes les arêtes (coûteux en mémoire).

\subsection{Prim (BFS)}

Parcours en largeur pour explorer chaque composante :
\begin{enumerate}
    \item Pour chaque pixel non labellisé
    \item Lancer un BFS qui visite tous les pixels connectés
    \item Affecter le même label à tous les pixels visités
\end{enumerate}

\textbf{Complexité :} $O(n)$ en temps, $O(n)$ en espace pour la file.

% ===========================================
% ARCHITECTURE
% ===========================================
\newpage
\section{Architecture du Projet}

\subsection{Structure}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Module} & \textbf{Description} \\
\midrule
\texttt{src/core/image.py} & Classes Image, LabelImage, ColorImage \\
\texttt{src/readers/image\_io.py} & Lecture/écriture d'images (PGM, PNG, etc.) \\
\texttt{src/algorithms/two\_pass.py} & Algorithme Two-Pass \\
\texttt{src/algorithms/union\_find.py} & Algorithme Union-Find \\
\texttt{src/algorithms/kruskal.py} & Algorithme Kruskal \\
\texttt{src/algorithms/prim.py} & Algorithme Prim (BFS) \\
\texttt{src/utils/utils.py} & Utilitaires (Timer, statistiques) \\
\texttt{benchmarks/} & Scripts de benchmark \\
\bottomrule
\end{tabular}
\caption{Organisation des modules}
\end{table}

\subsection{Interface commune}

Tous les algorithmes implémentent la même interface :
\begin{lstlisting}
@staticmethod
def label(image: Image, connectivity: int) -> LabelImage
\end{lstlisting}

% ===========================================
% PROTOCOLE EXPÉRIMENTAL
% ===========================================
\newpage
\section{Protocole Expérimental}

\subsection{Configuration}

\begin{itemize}
    \item \textbf{Langage :} Python 3.11
    \item \textbf{Nombre de runs :} 5 par configuration
    \item \textbf{Connectivités :} 4 et 8
\end{itemize}

\subsection{Images de test}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Image} & \textbf{Taille} & \textbf{Comp. (4-conn)} & \textbf{Comp. (8-conn)} \\
\midrule
images.png & petite & 5 & 4 \\
figure-65.png & moyenne & 31 & 31 \\
text image.png & grande & 67 & 67 \\
\bottomrule
\end{tabular}
\caption{Caractéristiques des images de test}
\end{table}

% ===========================================
% RÉSULTATS
% ===========================================
\newpage
\section{Résultats Expérimentaux}

\subsection{Comparaison globale}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Algorithme} & \textbf{Temps moyen (ms)} & \textbf{Écart-type} & \textbf{Speedup} \\
\midrule
Two-Pass & 2437.70 & 21.88 & 1.00x \\
Union-Find & 2568.11 & 13.17 & 0.95x \\
Prim & 3273.58 & 12.97 & 0.74x \\
Kruskal & 4247.60 & 95.94 & 0.57x \\
\bottomrule
\end{tabular}
\caption{Performances moyennes (toutes images et connectivités)}
\end{table}

\subsection{Impact de la connectivité}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Algorithme} & \textbf{4-conn (ms)} & \textbf{8-conn (ms)} & \textbf{Augmentation} \\
\midrule
Two-Pass & 1990.30 & 2885.11 & +45\% \\
Union-Find & 1959.25 & 3176.98 & +62\% \\
Prim & 2190.39 & 4356.78 & +99\% \\
Kruskal & 3113.33 & 5381.87 & +73\% \\
\bottomrule
\end{tabular}
\caption{Impact de la connectivité}
\end{table}

\subsection{Validation de la complexité}

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \textbf{64×64} & \textbf{128×128} & \textbf{256×256} & \textbf{512×512} \\
\midrule
Two-Pass & 4.80 ms & 20.95 ms & 76.22 ms & 315.44 ms \\
Union-Find & 4.44 ms & 18.05 ms & 73.82 ms & 305.74 ms \\
Kruskal & 5.44 ms & 20.34 ms & 92.05 ms & 377.61 ms \\
Prim & 3.77 ms & 14.31 ms & 58.31 ms & 248.27 ms \\
\bottomrule
\end{tabular}
\caption{Temps d'exécution selon la taille (facteur ×4 entre colonnes)}
\end{table}

Les résultats confirment une complexité linéaire $O(N)$ : le temps quadruple quand la taille quadruple.

% ===========================================
% DISCUSSION
% ===========================================
\newpage
\section{Discussion}

\subsection{Analyse des algorithmes}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Algorithme} & \textbf{Forces} & \textbf{Faiblesses} \\
\midrule
Two-Pass & Localité cache, simplicité & Deux passes requises \\
Union-Find & Élégance théorique & Accès mémoire dispersés \\
Kruskal & Modèle graphe explicite & Coût création arêtes \\
Prim (BFS) & Approche intuitive & Gestion file BFS \\
\bottomrule
\end{tabular}
\caption{Comparaison qualitative}
\end{table}

\subsection{Impact de la connectivité}

Le passage de 4-conn à 8-conn entraîne une augmentation de 45\% à 99\% du temps d'exécution :
\begin{itemize}
    \item Plus de voisins à examiner (8 vs 4)
    \item Plus d'opérations Union/Find
    \item Pour Kruskal : nombre d'arêtes doublé
\end{itemize}

\subsection{Validité}

Tous les algorithmes trouvent le même nombre de composantes, validant la correction des implémentations. Les faibles écarts-types (<5\%) confirment la reproductibilité.

% ===========================================
% CONCLUSION
% ===========================================
\newpage
\section{Conclusion}

\subsection{Synthèse}

\begin{enumerate}
    \item \textbf{Two-Pass} : Le plus performant, excellente localité de cache
    \item \textbf{Union-Find} : Performances proches, implémentation élégante
    \item \textbf{Prim (BFS)} : Performances intermédiaires
    \item \textbf{Kruskal} : Pénalisé par la création des arêtes
\end{enumerate}

\subsection{Recommandations}

\begin{itemize}
    \item Two-Pass pour les performances optimales
    \item Union-Find pour la flexibilité
    \item Préférer la 4-connexité sauf besoin explicite
\end{itemize}

\subsection{Perspectives}

\begin{itemize}
    \item Parallélisation multi-cœurs
    \item Extension aux images 3D
    \item Algorithmes récents (block-based, run-based)
\end{itemize}

% ===========================================
% RÉPARTITION DU TRAVAIL
% ===========================================
\newpage
\section*{Répartition du travail}
\addcontentsline{toc}{section}{Répartition du travail}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Tâche} & \textbf{R.D.} & \textbf{N.M.} & \textbf{A.B.} \\
\midrule
\textit{Algorithmes} & & & \\
\quad Two-Pass & $\bullet$ & & $\bullet$ \\
\quad Union-Find & $\bullet$ & $\bullet$ & \\
\quad Kruskal & & $\bullet$ & $\bullet$ \\
\quad Prim & & $\bullet$ & $\bullet$ \\
\midrule
\textit{Infrastructure} & & & \\
\quad Architecture & $\bullet$ & & $\bullet$ \\
\quad Classes Image & $\bullet$ & $\bullet$ & \\
\quad I/O images & & $\bullet$ & $\bullet$ \\
\midrule
\textit{Benchmarks} & & & \\
\quad Protocole & $\bullet$ & $\bullet$ & \\
\quad Scripts & & $\bullet$ & $\bullet$ \\
\quad Analyse & $\bullet$ & & $\bullet$ \\
\midrule
\textit{Rapport} & & & \\
\quad Théorie & $\bullet$ & & $\bullet$ \\
\quad Algorithmes & $\bullet$ & $\bullet$ & \\
\quad Résultats & & $\bullet$ & $\bullet$ \\
\bottomrule
\end{tabular}
\caption*{$\bullet$ = contribution principale}
\end{table}

% ===========================================
% BIBLIOGRAPHIE
% ===========================================
\newpage
\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{shapiro2001}
L. Shapiro et G. Stockman,
\textit{Computer Vision},
Prentice Hall, 2001.

\bibitem{rosenfeld1966}
A. Rosenfeld et J.L. Pfaltz,
``Sequential Operations in Digital Picture Processing,''
\textit{Journal of the ACM}, vol. 13, no. 4, pp. 471-494, 1966.

\bibitem{tarjan1975}
R.E. Tarjan,
``Efficiency of a Good But Not Linear Set Union Algorithm,''
\textit{Journal of the ACM}, vol. 22, no. 2, pp. 215-225, 1975.

\bibitem{wu2009}
K. Wu, E. Otoo, et K. Suzuki,
``Optimizing two-pass connected-component labeling algorithms,''
\textit{Pattern Analysis and Applications}, vol. 12, no. 2, 2009.

\bibitem{he2017}
L. He et al.,
``The connected-component labeling problem: A review,''
\textit{Pattern Recognition}, vol. 70, pp. 25-43, 2017.

\end{thebibliography}

\end{document}
