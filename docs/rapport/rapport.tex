\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\geometry{margin=2.5cm}

% Configuration des listings pour Python
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4
}

% Configuration hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Labellisation des Composantes Connexes},
    pdfauthor={Despoullain, Marano, Braham}
}

% Informations du document
\title{
    \textbf{Labellisation des Composantes Connexes} \\
    \large Analyse Comparative de Quatre Algorithmes \\
    \vspace{0.5cm}
    \normalsize Projet de Traitement d'Images
}
\author{
    Romain Despoullain \\
    Nicolas Marano \\
    Amin Braham
}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Ce rapport présente une étude comparative de quatre algorithmes de labellisation des composantes connexes pour images binaires : Two-Pass, Union-Find, Kruskal et Prim. L'implémentation a été réalisée en Python avec la contrainte que NumPy et OpenCV ne sont utilisés que pour le chargement des images ; tous les traitements algorithmiques sont effectués manuellement. Les expérimentations menées sur trois images de test avec les connectivités 4 et 8 démontrent que les algorithmes Two-Pass et Union-Find offrent les meilleures performances, tandis que Kruskal présente un surcoût significatif dû à la création explicite des arêtes du graphe.
\end{abstract}

\newpage
\tableofcontents
\newpage

% ============================================================================
\section{Introduction}
% ============================================================================

\subsection{Contexte et motivation}

La \textbf{labellisation des composantes connexes} (Connected Component Labeling - CCL) est une opération fondamentale en traitement d'images numériques. Elle consiste à identifier et étiqueter les régions connexes dans une image binaire, c'est-à-dire les ensembles de pixels adjacents partageant la même valeur.

Cette technique trouve des applications dans de nombreux domaines :
\begin{itemize}
    \item \textbf{Vision par ordinateur} : détection et reconnaissance d'objets
    \item \textbf{Analyse de documents} : segmentation de caractères, extraction de texte
    \item \textbf{Imagerie médicale} : identification de structures anatomiques, détection de tumeurs
    \item \textbf{Contrôle qualité industriel} : inspection automatique de produits
    \item \textbf{Télédétection} : analyse d'images satellites
\end{itemize}

\subsection{Définition formelle du problème}

Soit une image binaire $I : \Omega \rightarrow \{0, 1\}$ où $\Omega \subset \mathbb{Z}^2$ représente le domaine de l'image. Le problème de la labellisation consiste à trouver une fonction $L : \Omega \rightarrow \mathbb{N}$ telle que :

\begin{equation}
    L(p) = L(q) \Leftrightarrow p \sim q
\end{equation}

où $p \sim q$ signifie que les pixels $p$ et $q$ appartiennent à la même composante connexe, c'est-à-dire qu'il existe un chemin de pixels adjacents de valeur 1 reliant $p$ à $q$.

\subsection{Objectifs du projet}

Ce projet vise à :
\begin{enumerate}
    \item Implémenter quatre algorithmes différents de labellisation des composantes connexes
    \item Comparer leurs performances sur différentes images et configurations
    \item Analyser l'impact de la connectivité (4 vs 8 voisins) sur les résultats
    \item Fournir une analyse statistique rigoureuse basée sur des benchmarks reproductibles
\end{enumerate}

\subsection{Contraintes d'implémentation}

Le projet a été développé en Python avec une contrainte importante : \textbf{NumPy et OpenCV ne sont utilisés que pour le chargement et la sauvegarde des images}. Toutes les opérations algorithmiques (parcours, comparaisons, structures de données) sont implémentées manuellement, permettant une compréhension approfondie des mécanismes sous-jacents.

% ============================================================================
\section{Fondements Théoriques}
% ============================================================================

\subsection{Topologie Discrète}

\subsubsection{Notion d'adjacence}

La connexité entre pixels repose sur la notion d'\textbf{adjacence}. Pour deux pixels $p = (x_1, y_1)$ et $q = (x_2, y_2)$, on définit :

\paragraph{4-adjacence (connexité forte) :} Les pixels sont 4-adjacents si et seulement si :
\begin{equation}
    |x_1 - x_2| + |y_1 - y_2| = 1
\end{equation}

Cela correspond aux quatre voisins directs : Nord $(x, y-1)$, Sud $(x, y+1)$, Est $(x+1, y)$, Ouest $(x-1, y)$.

\paragraph{8-adjacence (connexité faible) :} Les pixels sont 8-adjacents si et seulement si :
\begin{equation}
    \max(|x_1 - x_2|, |y_1 - y_2|) = 1
\end{equation}

Cela inclut les quatre voisins diagonaux en plus des voisins directs.

\subsubsection{Composante connexe}

Une \textbf{composante connexe} $C$ est un sous-ensemble maximal de pixels de l'image tel que pour tout couple de pixels $(p, q) \in C^2$, il existe une chaîne de pixels $(p_0, p_1, ..., p_n)$ avec $p_0 = p$, $p_n = q$, et $p_i$ adjacent à $p_{i+1}$ pour tout $i$.

\subsubsection{Paradoxe de Jordan}

Le \textbf{paradoxe de l'échiquier de Jordan} démontre l'importance du choix de la connexité. Si l'on utilise la même connexité pour l'objet (pixels blancs) et le fond (pixels noirs), des incohérences topologiques apparaissent. La solution standard consiste à utiliser des \textbf{adjacences duales} :
\begin{itemize}
    \item 4-connexité pour l'objet
    \item 8-connexité pour le fond (ou vice-versa)
\end{itemize}

\subsection{Modélisation par graphe}

L'image peut être modélisée comme un graphe non orienté $G = (V, E)$ :
\begin{itemize}
    \item $V$ : ensemble des pixels (sommets)
    \item $E$ : ensemble des paires de pixels adjacents de même valeur (arêtes)
\end{itemize}

Dans cette représentation, les composantes connexes correspondent aux \textbf{composantes connexes du graphe} au sens de la théorie des graphes.

\subsection{Structure Union-Find}

La structure de données \textbf{Union-Find} (ou Disjoint-Set) permet de gérer efficacement une partition d'un ensemble. Elle supporte deux opérations :
\begin{itemize}
    \item \texttt{Find(x)} : retourne le représentant de l'ensemble contenant $x$
    \item \texttt{Union(x, y)} : fusionne les ensembles contenant $x$ et $y$
\end{itemize}

Avec les optimisations de \textbf{compression de chemin} et d'\textbf{union par rang}, la complexité amortie de chaque opération est $O(\alpha(n))$, où $\alpha$ est la fonction inverse d'Ackermann, qui croît extrêmement lentement (pratiquement constante pour toute valeur réaliste de $n$).

% ============================================================================
\section{Description des Algorithmes}
% ============================================================================

\subsection{Algorithme Two-Pass}

\subsubsection{Principe}

L'algorithme Two-Pass est l'approche classique de la labellisation. Il effectue deux parcours complets de l'image :

\paragraph{Première passe :} Attribution d'étiquettes provisoires
\begin{algorithm}[H]
\caption{Two-Pass - Première passe}
\begin{algorithmic}[1]
\State $label \gets 1$
\State Initialiser table d'équivalences $equiv$
\For{$(x, y) \in \Omega$ (parcours raster)}
    \If{$I(x, y) = 1$}
        \State $N \gets$ \{voisins déjà traités avec $I(n) = 1$\}
        \If{$N = \emptyset$}
            \State $L(x, y) \gets label$
            \State $label \gets label + 1$
        \Else
            \State $L(x, y) \gets \min_{n \in N} L(n)$
            \For{$n \in N$}
                \State $equiv.\text{union}(L(x, y), L(n))$
            \EndFor
        \EndIf
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\paragraph{Deuxième passe :} Résolution des équivalences
\begin{algorithm}[H]
\caption{Two-Pass - Deuxième passe}
\begin{algorithmic}[1]
\For{$(x, y) \in \Omega$}
    \If{$L(x, y) > 0$}
        \State $L(x, y) \gets equiv.\text{find}(L(x, y))$
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Complexité}
\begin{itemize}
    \item \textbf{Temporelle :} $O(n)$ où $n$ est le nombre de pixels
    \item \textbf{Spatiale :} $O(n)$ pour l'image de labels
\end{itemize}

\subsubsection{Avantages}
\begin{itemize}
    \item Excellente localité de cache (parcours séquentiel)
    \item Simple à implémenter et à comprendre
    \item Très efficace en pratique
\end{itemize}

\subsection{Algorithme Union-Find}

\subsubsection{Principe}

Cet algorithme utilise directement la structure Union-Find pour gérer les composantes connexes. Chaque pixel est initialement dans son propre ensemble, puis les ensembles sont fusionnés lors du parcours.

\begin{algorithm}[H]
\caption{Union-Find Labeling}
\begin{algorithmic}[1]
\State Initialiser $parent[p] \gets p$ et $rank[p] \gets 0$ pour tout $p$
\For{$(x, y) \in \Omega$ (parcours raster)}
    \If{$I(x, y) = 1$}
        \For{$n \in$ voisins adjacents avec $I(n) = 1$}
            \State $\text{Union}((x, y), n)$
        \EndFor
    \EndIf
\EndFor
\State Assigner des labels consécutifs aux représentants
\end{algorithmic}
\end{algorithm}

\subsubsection{Optimisations}

\paragraph{Compression de chemin :} Lors de \texttt{Find}, tous les nœuds parcourus pointent directement vers la racine.
\begin{lstlisting}[language=Python, caption=Compression de chemin]
def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])
    return self.parent[x]
\end{lstlisting}

\paragraph{Union par rang :} Lors de \texttt{Union}, l'arbre de rang inférieur est attaché sous l'arbre de rang supérieur.

\subsubsection{Complexité}
\begin{itemize}
    \item \textbf{Temporelle :} $O(n \cdot \alpha(n)) \approx O(n)$
    \item \textbf{Spatiale :} $O(n)$ pour les tableaux parent et rank
\end{itemize}

\subsection{Algorithme de Kruskal}

\subsubsection{Principe}

L'algorithme de Kruskal, traditionnellement utilisé pour trouver l'arbre couvrant minimum d'un graphe, est adapté à la labellisation. L'image est modélisée comme un graphe où les arêtes connectent les pixels voisins de même valeur.

\begin{algorithm}[H]
\caption{Kruskal Labeling}
\begin{algorithmic}[1]
\State $edges \gets \emptyset$
\For{$(x, y) \in \Omega$}
    \If{$I(x, y) = 1$}
        \For{$n \in$ voisins adjacents avec $I(n) = 1$}
            \State $edges \gets edges \cup \{((x, y), n)\}$
        \EndFor
    \EndIf
\EndFor
\State Initialiser Union-Find
\For{$(u, v) \in edges$}
    \If{$\text{Find}(u) \neq \text{Find}(v)$}
        \State $\text{Union}(u, v)$
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Complexité}
\begin{itemize}
    \item \textbf{Temporelle :} $O(E \cdot \alpha(V))$ où $E$ est le nombre d'arêtes
    \item \textbf{Spatiale :} $O(E + V)$ pour stocker les arêtes
\end{itemize}

\subsubsection{Inconvénients}

Le principal inconvénient est la nécessité de créer explicitement toutes les arêtes, ce qui représente un surcoût significatif en mémoire et en temps.

\subsection{Algorithme de Prim (BFS)}

\subsubsection{Principe}

Cette approche utilise un parcours en largeur (BFS) pour explorer chaque composante connexe. Pour chaque pixel non encore labellisé, on lance un BFS qui visite tous les pixels connectés.

\begin{algorithm}[H]
\caption{Prim/BFS Labeling}
\begin{algorithmic}[1]
\State $label \gets 0$
\For{$(x, y) \in \Omega$}
    \If{$I(x, y) = 1$ et $L(x, y) = 0$}
        \State $label \gets label + 1$
        \State $queue \gets \{(x, y)\}$
        \While{$queue \neq \emptyset$}
            \State $(cx, cy) \gets queue.\text{pop}()$
            \If{$L(cx, cy) = 0$}
                \State $L(cx, cy) \gets label$
                \For{$n \in$ voisins adjacents avec $I(n) = 1$}
                    \State $queue.\text{push}(n)$
                \EndFor
            \EndIf
        \EndWhile
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Complexité}
\begin{itemize}
    \item \textbf{Temporelle :} $O(n)$
    \item \textbf{Spatiale :} $O(n)$ pour la file BFS dans le pire cas
\end{itemize}

% ============================================================================
\section{Architecture du Projet}
% ============================================================================

\subsection{Structure des fichiers}

Le projet est organisé selon une architecture modulaire :

\begin{verbatim}
labellisation/
├── src/
│   ├── __init__.py           # Package principal
│   ├── main.py               # Point d'entrée
│   ├── core/
│   │   ├── __init__.py
│   │   └── image.py          # Classes Image, LabelImage, Pixel
│   ├── readers/
│   │   ├── __init__.py
│   │   └── image_io.py       # Lecture/écriture d'images
│   ├── algorithms/
│   │   ├── __init__.py
│   │   ├── two_pass.py       # Algorithme Two-Pass
│   │   ├── union_find.py     # Algorithme Union-Find
│   │   ├── kruskal.py        # Algorithme Kruskal
│   │   └── prim.py           # Algorithme Prim
│   └── utils/
│       └── utils.py          # Utilitaires (Timer, etc.)
├── benchmarks/
│   ├── scientific_benchmark.py
│   ├── generate_graphs.py
│   └── run_all.py
└── images/
    └── input/                # Images de test
\end{verbatim}

\subsection{Classes principales}

\subsubsection{Classe Image}

La classe \texttt{Image} représente une image en niveaux de gris :

\begin{lstlisting}[language=Python, caption=Classe Image (extrait)]
class Image:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.pixels = [[0] * width for _ in range(height)]

    def binarize(self, threshold: int):
        """Binarise l'image avec un seuil."""
        for y in range(self.height):
            for x in range(self.width):
                self.pixels[y][x] = 1 if self.pixels[y][x] >= threshold else 0
\end{lstlisting}

\subsubsection{Classe LabelImage}

La classe \texttt{LabelImage} hérite de \texttt{Image} et stocke les étiquettes :

\begin{lstlisting}[language=Python, caption=Classe LabelImage (extrait)]
class LabelImage(Image):
    def count_labels(self) -> int:
        """Compte le nombre de composantes connexes."""
        labels = set()
        for y in range(self.height):
            for x in range(self.width):
                if self.pixels[y][x] > 0:
                    labels.add(self.pixels[y][x])
        return len(labels)
\end{lstlisting}

\subsection{Interface des algorithmes}

Tous les algorithmes implémentent une interface uniforme :

\begin{lstlisting}[language=Python, caption=Interface commune]
@staticmethod
def label(image: Image, connectivity: int) -> LabelImage:
    """
    Labellise les composantes connexes de l'image.

    Args:
        image: Image binaire à traiter
        connectivity: 4 ou 8 voisins

    Returns:
        Image labellisée
    """
\end{lstlisting}

% ============================================================================
\section{Protocole Expérimental}
% ============================================================================

\subsection{Configuration des tests}

\subsubsection{Environnement}

Les tests ont été effectués avec la configuration suivante :
\begin{itemize}
    \item \textbf{Langage :} Python 3.11
    \item \textbf{Système d'exploitation :} Windows 10/11
    \item \textbf{Dépendances :} NumPy (chargement images uniquement), OpenCV (I/O images)
\end{itemize}

\subsubsection{Images de test}

Trois images de test ont été utilisées :

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Image} & \textbf{Dimensions} & \textbf{Composantes (4-conn)} & \textbf{Composantes (8-conn)} \\
\midrule
images.png & petite & 5 & 4 \\
figure-65.png & moyenne & 31 & 31 \\
text image.png & grande & 67 & 67 \\
\bottomrule
\end{tabular}
\caption{Caractéristiques des images de test}
\label{tab:images}
\end{table}

\subsubsection{Paramètres du benchmark}

\begin{itemize}
    \item \textbf{Nombre de runs :} 5 par configuration
    \item \textbf{Connectivités :} 4 et 8
    \item \textbf{Algorithmes :} Two-Pass, Union-Find, Kruskal, Prim
    \item \textbf{Métriques :} temps moyen, écart-type, min, max
\end{itemize}

% ============================================================================
\section{Résultats Expérimentaux}
% ============================================================================

\subsection{Résultats globaux}

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \textbf{Temps moyen (ms)} & \textbf{Écart-type (ms)} & \textbf{Speedup} \\
\midrule
Two-Pass & 2437.70 & 21.88 & 1.00x \\
Union-Find & 2568.11 & 13.17 & 0.95x \\
Prim & 3273.58 & 12.97 & 0.74x \\
Kruskal & 4247.60 & 95.94 & 0.57x \\
\bottomrule
\end{tabular}
\caption{Comparaison globale des performances (moyenne sur toutes les images et connectivités)}
\label{tab:global}
\end{table}

\subsection{Résultats par image et connectivité}

\subsubsection{Image : figure-65.png (31 composantes)}

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \multicolumn{2}{c}{\textbf{Connectivité 4}} & \multicolumn{2}{c}{\textbf{Connectivité 8}} \\
 & Temps (ms) & $\sigma$ & Temps (ms) & $\sigma$ \\
\midrule
Two-Pass & 720.01 & 6.02 & 1029.55 & 7.76 \\
Union-Find & 698.93 & 7.30 & 1121.50 & 5.08 \\
Prim & 764.47 & 3.72 & 1475.94 & 8.89 \\
Kruskal & 1083.27 & 19.50 & 1906.23 & 29.84 \\
\bottomrule
\end{tabular}
\caption{Performances sur figure-65.png}
\end{table}

\subsubsection{Image : images.png (5/4 composantes)}

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \multicolumn{2}{c}{\textbf{Connectivité 4}} & \multicolumn{2}{c}{\textbf{Connectivité 8}} \\
 & Temps (ms) & $\sigma$ & Temps (ms) & $\sigma$ \\
\midrule
Union-Find & 118.62 & 2.71 & 194.01 & 9.33 \\
Two-Pass & 119.41 & 0.69 & 172.99 & 0.58 \\
Prim & 130.32 & 1.77 & 251.80 & 3.78 \\
Kruskal & 162.69 & 4.09 & 298.43 & 8.18 \\
\bottomrule
\end{tabular}
\caption{Performances sur images.png}
\end{table}

\subsubsection{Image : text image.png (67 composantes)}

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \multicolumn{2}{c}{\textbf{Connectivité 4}} & \multicolumn{2}{c}{\textbf{Connectivité 8}} \\
 & Temps (ms) & $\sigma$ & Temps (ms) & $\sigma$ \\
\midrule
Union-Find & 5060.18 & 34.50 & 8215.42 & 21.13 \\
Two-Pass & 5131.49 & 31.83 & 7452.78 & 30.98 \\
Prim & 5676.37 & 33.80 & 11342.60 & 25.83 \\
Kruskal & 8094.03 & 177.73 & 13940.96 & 336.47 \\
\bottomrule
\end{tabular}
\caption{Performances sur text image.png}
\end{table}

\subsection{Analyse de l'impact de la connectivité}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Algorithme} & \textbf{Temps 4-conn (ms)} & \textbf{Temps 8-conn (ms)} & \textbf{Augmentation (\%)} \\
\midrule
Two-Pass & 1990.30 & 2885.11 & +44.96\% \\
Union-Find & 1959.25 & 3176.98 & +62.15\% \\
Prim & 2190.39 & 4356.78 & +98.91\% \\
Kruskal & 3113.33 & 5381.87 & +72.87\% \\
\bottomrule
\end{tabular}
\caption{Impact de la connectivité sur les performances}
\label{tab:connectivity}
\end{table}

La connectivité 8 entraîne une augmentation significative du temps d'exécution, principalement due au nombre supérieur de voisins à examiner (8 au lieu de 4).

\subsection{Vérification de cohérence}

\begin{table}[H]
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Image} & \textbf{4-connexité} & \textbf{8-connexité} \\
\midrule
figure-65.png & 31 $\checkmark$ & 31 $\checkmark$ \\
images.png & 5 $\checkmark$ & 4 $\checkmark$ \\
text image.png & 67 $\checkmark$ & 67 $\checkmark$ \\
\bottomrule
\end{tabular}
\caption{Vérification de cohérence : tous les algorithmes trouvent le même nombre de composantes}
\label{tab:coherence}
\end{table}

% ============================================================================
\section{Discussion}
% ============================================================================

\subsection{Analyse de la complexité empirique}

Pour valider la complexité théorique $O(N)$ des algorithmes, nous avons mesuré le temps d'exécution en fonction du nombre de pixels sur des images de tailles croissantes (64x64, 128x128, 256x256, 512x512).

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithme} & \textbf{64x64} & \textbf{128x128} & \textbf{256x256} & \textbf{512x512} \\
 & (4K px) & (16K px) & (65K px) & (262K px) \\
\midrule
Two-Pass & 4.80 ms & 20.95 ms & 76.22 ms & 315.44 ms \\
Union-Find & 4.44 ms & 18.05 ms & 73.82 ms & 305.74 ms \\
Kruskal & 5.44 ms & 20.34 ms & 92.05 ms & 377.61 ms \\
Prim & 3.77 ms & 14.31 ms & 58.31 ms & 248.27 ms \\
\bottomrule
\end{tabular}
\caption{Temps d'exécution en fonction de la taille de l'image}
\label{tab:complexity}
\end{table}

Les résultats confirment une complexité quasi-linéaire : lorsque le nombre de pixels est multiplié par 4, le temps d'exécution est également multiplié par environ 4, ce qui valide la complexité $O(N)$ attendue.

\subsection{Analyse critique des algorithmes}

\subsubsection{Two-Pass : l'approche classique}

\textbf{Forces :}
\begin{itemize}
    \item Excellente \textbf{localité de cache} grâce au parcours raster séquentiel
    \item Simple à implémenter et à comprendre
    \item Très efficace en pratique sur les architectures modernes
\end{itemize}

\textbf{Faiblesses :}
\begin{itemize}
    \item Nécessite deux passes complètes de l'image
    \item Gestion de la \textbf{table d'équivalence} délicate (risque de bugs lors de conflits de labels)
    \item Difficilement parallélisable (dépendances entre pixels voisins)
\end{itemize}

\subsubsection{Union-Find : l'élégance théorique}

\textbf{Forces :}
\begin{itemize}
    \item Basé sur le \textbf{modèle de partition} (CM05), conceptuellement élégant
    \item Structure réutilisable pour d'autres problèmes de partitionnement
    \item Complexité quasi-optimale $O(N \cdot \alpha(N))$ avec les optimisations
\end{itemize}

\textbf{Faiblesses :}
\begin{itemize}
    \item Accès mémoire non-séquentiels lors des opérations Find (moins cache-friendly)
    \item Surcoût mémoire pour les tableaux \texttt{parent} et \texttt{rank}
    \item Implémentation plus complexe que Two-Pass
\end{itemize}

\subsubsection{Kruskal : la modélisation par graphe}

\textbf{Forces :}
\begin{itemize}
    \item Illustre parfaitement la \textbf{modélisation par graphe} (CM03)
    \item Théoriquement élégant (Arbre Couvrant Minimum)
    \item Facile à comprendre pour qui connaît la théorie des graphes
\end{itemize}

\textbf{Faiblesses :}
\begin{itemize}
    \item \textbf{Création explicite de toutes les arêtes} : très coûteux en mémoire
    \item Pour une image $N \times N$, environ $2N^2$ arêtes (4-connexité) ou $4N^2$ arêtes (8-connexité)
    \item Surcoût d'itération sur l'ensemble des arêtes
    \item \textbf{Non adapté aux grandes images} (mémoire insuffisante pour les images 4K)
\end{itemize}

\subsubsection{Prim (BFS) : l'exploration intuitive}

\textbf{Forces :}
\begin{itemize}
    \item Approche intuitive par exploration de voisinage
    \item Une seule passe principale
    \item Bonne localité pour les composantes compactes
\end{itemize}

\textbf{Faiblesses :}
\begin{itemize}
    \item Surcoût de gestion de la file BFS
    \item Allocations mémoire dynamiques fréquentes
    \item Moins performant que Two-Pass sur les grandes images
\end{itemize}

\subsection{Lien avec la morphologie mathématique}

La labellisation des composantes connexes est une étape fondamentale pour de nombreux opérateurs de morphologie mathématique (CM05). En particulier, elle constitue l'étape préliminaire à la construction du \textbf{Component-Tree} (Arbre des composantes), une structure hiérarchique permettant :

\begin{itemize}
    \item Le \textbf{filtrage par attributs} : supprimer les composantes selon leur surface, périmètre, etc.
    \item L'\textbf{analyse multi-échelle} : étudier les objets à différents niveaux de seuillage
    \item La \textbf{segmentation morphologique} : watershed, etc.
\end{itemize}

\subsection{Impact de la connectivité}

Le passage de la 4-connexité à la 8-connexité entraîne une augmentation du temps d'exécution comprise entre 45\% et 99\% selon l'algorithme. Cette augmentation est due à :

\begin{itemize}
    \item Un nombre supérieur de voisins à examiner (8 au lieu de 4)
    \item Plus d'opérations Union/Find pour fusionner les composantes
    \item Pour Kruskal, un nombre d'arêtes environ doublé
\end{itemize}

Le choix de la connectivité doit être guidé par l'application : la 4-connexité est plus restrictive mais évite les connexions "parasites" par les diagonales.

\subsection{Validité des résultats}

La cohérence des résultats entre algorithmes (même nombre de composantes) valide la correction de toutes les implémentations. Les faibles écarts-types observés ($<5\%$ dans la plupart des cas) confirment la reproductibilité des mesures.

% ============================================================================
\section{Conclusion}
% ============================================================================

\subsection{Synthèse}

Ce projet a permis d'implémenter et de comparer quatre algorithmes de labellisation des composantes connexes :

\begin{enumerate}
    \item \textbf{Two-Pass} : Algorithme le plus performant dans la majorité des cas, particulièrement sur les grandes images
    \item \textbf{Union-Find} : Performances très proches de Two-Pass, avec une implémentation élégante basée sur la théorie des ensembles
    \item \textbf{Prim (BFS)} : Performances intermédiaires, approche intuitive par exploration
    \item \textbf{Kruskal} : Le moins performant, principalement pénalisé par la création des arêtes
\end{enumerate}

\subsection{Recommandations pratiques}

Pour une utilisation en production, nous recommandons :
\begin{itemize}
    \item \textbf{Two-Pass} pour des performances optimales sur de grandes images
    \item \textbf{Union-Find} pour sa flexibilité et son élégance conceptuelle
    \item \textbf{Connectivité 4} sauf si l'application nécessite explicitement la 8-connexité
\end{itemize}

\subsection{Perspectives}

Des améliorations possibles incluent :
\begin{itemize}
    \item Parallélisation des algorithmes pour exploiter les processeurs multi-cœurs
    \item Optimisation mémoire pour le traitement de très grandes images
    \item Extension aux images multi-spectrales ou 3D
    \item Implémentation d'algorithmes plus récents (block-based, run-based)
\end{itemize}

% ============================================================================
\section*{Répartition du travail}
% ============================================================================

\begin{itemize}
    \item \textbf{Romain Despoullain} : Implémentation Two-Pass et Union-Find, sections théoriques
    \item \textbf{Nicolas Marano} : Implémentation Kruskal et Prim, benchmarks, graphiques
    \item \textbf{Amin Braham} : Architecture du projet, I/O images, rapport LaTeX
\end{itemize}

% ============================================================================
\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{shapiro2001}
L. Shapiro et G. Stockman,
\textit{Computer Vision},
Prentice Hall, 2001.

\bibitem{rosenfeld1966}
A. Rosenfeld et J.L. Pfaltz,
``Sequential Operations in Digital Picture Processing,''
\textit{Journal of the ACM}, vol. 13, no. 4, pp. 471-494, 1966.

\bibitem{tarjan1975}
R.E. Tarjan,
``Efficiency of a Good But Not Linear Set Union Algorithm,''
\textit{Journal of the ACM}, vol. 22, no. 2, pp. 215-225, 1975.

\bibitem{wu2009}
K. Wu, E. Otoo, et K. Suzuki,
``Optimizing two-pass connected-component labeling algorithms,''
\textit{Pattern Analysis and Applications}, vol. 12, no. 2, pp. 117-135, 2009.

\bibitem{he2017}
L. He, X. Ren, Q. Gao, et al.,
``The connected-component labeling problem: A review of state-of-the-art algorithms,''
\textit{Pattern Recognition}, vol. 70, pp. 25-43, 2017.

\end{thebibliography}

% ============================================================================
\appendix
\section{Graphiques de performance}
% ============================================================================

Les graphiques générés par le benchmark sont disponibles dans le répertoire \texttt{benchmarks/results/graphs/} :

\begin{itemize}
    \item \texttt{comparison\_algorithms.png} : Comparaison globale des algorithmes
    \item \texttt{comparison\_images.png} : Comparaison par image
    \item \texttt{connectivity\_comparison.png} : Impact de la connectivité
    \item \texttt{speedup.png} : Speedup relatif (référence : Two-Pass)
    \item \texttt{components\_verification.png} : Vérification de cohérence
\end{itemize}

% Inclure les graphiques s'ils existent
\iffalse
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../../benchmarks/results/graphs/comparison_algorithms.png}
    \caption{Comparaison globale des algorithmes}
\end{figure}
\fi

\end{document}
